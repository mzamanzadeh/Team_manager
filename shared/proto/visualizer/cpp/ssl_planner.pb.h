// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl_planner.proto

#ifndef PROTOBUF_ssl_5fplanner_2eproto__INCLUDED
#define PROTOBUF_ssl_5fplanner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ssl_5fplanner_2eproto();
void protobuf_AssignDesc_ssl_5fplanner_2eproto();
void protobuf_ShutdownFile_ssl_5fplanner_2eproto();

class planner_vec3d;
class planner_point2d;
class planner_circle;
class planner_polygon;
class planner_obstacles;
class planner_plan;
class ssl_planner_packet;

// ===================================================================

class planner_vec3d : public ::google::protobuf::Message {
 public:
  planner_vec3d();
  virtual ~planner_vec3d();
  
  planner_vec3d(const planner_vec3d& from);
  
  inline planner_vec3d& operator=(const planner_vec3d& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const planner_vec3d& default_instance();
  
  void Swap(planner_vec3d* other);
  
  // implements Message ----------------------------------------------
  
  planner_vec3d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const planner_vec3d& from);
  void MergeFrom(const planner_vec3d& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float teta = 3;
  inline bool has_teta() const;
  inline void clear_teta();
  static const int kTetaFieldNumber = 3;
  inline float teta() const;
  inline void set_teta(float value);
  
  // @@protoc_insertion_point(class_scope:planner_vec3d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_teta();
  inline void clear_has_teta();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float teta_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static planner_vec3d* default_instance_;
};
// -------------------------------------------------------------------

class planner_point2d : public ::google::protobuf::Message {
 public:
  planner_point2d();
  virtual ~planner_point2d();
  
  planner_point2d(const planner_point2d& from);
  
  inline planner_point2d& operator=(const planner_point2d& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const planner_point2d& default_instance();
  
  void Swap(planner_point2d* other);
  
  // implements Message ----------------------------------------------
  
  planner_point2d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const planner_point2d& from);
  void MergeFrom(const planner_point2d& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:planner_point2d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static planner_point2d* default_instance_;
};
// -------------------------------------------------------------------

class planner_circle : public ::google::protobuf::Message {
 public:
  planner_circle();
  virtual ~planner_circle();
  
  planner_circle(const planner_circle& from);
  
  inline planner_circle& operator=(const planner_circle& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const planner_circle& default_instance();
  
  void Swap(planner_circle* other);
  
  // implements Message ----------------------------------------------
  
  planner_circle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const planner_circle& from);
  void MergeFrom(const planner_circle& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .planner_point2d center = 1;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 1;
  inline const ::planner_point2d& center() const;
  inline ::planner_point2d* mutable_center();
  inline ::planner_point2d* release_center();
  
  // required float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline float radius() const;
  inline void set_radius(float value);
  
  // optional float orien = 3;
  inline bool has_orien() const;
  inline void clear_orien();
  static const int kOrienFieldNumber = 3;
  inline float orien() const;
  inline void set_orien(float value);
  
  // @@protoc_insertion_point(class_scope:planner_circle)
 private:
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_orien();
  inline void clear_has_orien();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::planner_point2d* center_;
  float radius_;
  float orien_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static planner_circle* default_instance_;
};
// -------------------------------------------------------------------

class planner_polygon : public ::google::protobuf::Message {
 public:
  planner_polygon();
  virtual ~planner_polygon();
  
  planner_polygon(const planner_polygon& from);
  
  inline planner_polygon& operator=(const planner_polygon& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const planner_polygon& default_instance();
  
  void Swap(planner_polygon* other);
  
  // implements Message ----------------------------------------------
  
  planner_polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const planner_polygon& from);
  void MergeFrom(const planner_polygon& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .planner_point2d vertex = 1;
  inline int vertex_size() const;
  inline void clear_vertex();
  static const int kVertexFieldNumber = 1;
  inline const ::planner_point2d& vertex(int index) const;
  inline ::planner_point2d* mutable_vertex(int index);
  inline ::planner_point2d* add_vertex();
  inline const ::google::protobuf::RepeatedPtrField< ::planner_point2d >&
      vertex() const;
  inline ::google::protobuf::RepeatedPtrField< ::planner_point2d >*
      mutable_vertex();
  
  // optional float orien = 2;
  inline bool has_orien() const;
  inline void clear_orien();
  static const int kOrienFieldNumber = 2;
  inline float orien() const;
  inline void set_orien(float value);
  
  // @@protoc_insertion_point(class_scope:planner_polygon)
 private:
  inline void set_has_orien();
  inline void clear_has_orien();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::planner_point2d > vertex_;
  float orien_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static planner_polygon* default_instance_;
};
// -------------------------------------------------------------------

class planner_obstacles : public ::google::protobuf::Message {
 public:
  planner_obstacles();
  virtual ~planner_obstacles();
  
  planner_obstacles(const planner_obstacles& from);
  
  inline planner_obstacles& operator=(const planner_obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const planner_obstacles& default_instance();
  
  void Swap(planner_obstacles* other);
  
  // implements Message ----------------------------------------------
  
  planner_obstacles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const planner_obstacles& from);
  void MergeFrom(const planner_obstacles& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .planner_circle circles = 1;
  inline int circles_size() const;
  inline void clear_circles();
  static const int kCirclesFieldNumber = 1;
  inline const ::planner_circle& circles(int index) const;
  inline ::planner_circle* mutable_circles(int index);
  inline ::planner_circle* add_circles();
  inline const ::google::protobuf::RepeatedPtrField< ::planner_circle >&
      circles() const;
  inline ::google::protobuf::RepeatedPtrField< ::planner_circle >*
      mutable_circles();
  
  // repeated .planner_polygon polygons = 2;
  inline int polygons_size() const;
  inline void clear_polygons();
  static const int kPolygonsFieldNumber = 2;
  inline const ::planner_polygon& polygons(int index) const;
  inline ::planner_polygon* mutable_polygons(int index);
  inline ::planner_polygon* add_polygons();
  inline const ::google::protobuf::RepeatedPtrField< ::planner_polygon >&
      polygons() const;
  inline ::google::protobuf::RepeatedPtrField< ::planner_polygon >*
      mutable_polygons();
  
  // @@protoc_insertion_point(class_scope:planner_obstacles)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::planner_circle > circles_;
  ::google::protobuf::RepeatedPtrField< ::planner_polygon > polygons_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static planner_obstacles* default_instance_;
};
// -------------------------------------------------------------------

class planner_plan : public ::google::protobuf::Message {
 public:
  planner_plan();
  virtual ~planner_plan();
  
  planner_plan(const planner_plan& from);
  
  inline planner_plan& operator=(const planner_plan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const planner_plan& default_instance();
  
  void Swap(planner_plan* other);
  
  // implements Message ----------------------------------------------
  
  planner_plan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const planner_plan& from);
  void MergeFrom(const planner_plan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // repeated .planner_vec3d pathState = 2;
  inline int pathstate_size() const;
  inline void clear_pathstate();
  static const int kPathStateFieldNumber = 2;
  inline const ::planner_vec3d& pathstate(int index) const;
  inline ::planner_vec3d* mutable_pathstate(int index);
  inline ::planner_vec3d* add_pathstate();
  inline const ::google::protobuf::RepeatedPtrField< ::planner_vec3d >&
      pathstate() const;
  inline ::google::protobuf::RepeatedPtrField< ::planner_vec3d >*
      mutable_pathstate();
  
  // required .planner_vec3d initState = 3;
  inline bool has_initstate() const;
  inline void clear_initstate();
  static const int kInitStateFieldNumber = 3;
  inline const ::planner_vec3d& initstate() const;
  inline ::planner_vec3d* mutable_initstate();
  inline ::planner_vec3d* release_initstate();
  
  // required .planner_vec3d goalState = 4;
  inline bool has_goalstate() const;
  inline void clear_goalstate();
  static const int kGoalStateFieldNumber = 4;
  inline const ::planner_vec3d& goalstate() const;
  inline ::planner_vec3d* mutable_goalstate();
  inline ::planner_vec3d* release_goalstate();
  
  // required .planner_vec3d desiredVel = 5;
  inline bool has_desiredvel() const;
  inline void clear_desiredvel();
  static const int kDesiredVelFieldNumber = 5;
  inline const ::planner_vec3d& desiredvel() const;
  inline ::planner_vec3d* mutable_desiredvel();
  inline ::planner_vec3d* release_desiredvel();
  
  // required .planner_vec3d appliedVel = 6;
  inline bool has_appliedvel() const;
  inline void clear_appliedvel();
  static const int kAppliedVelFieldNumber = 6;
  inline const ::planner_vec3d& appliedvel() const;
  inline ::planner_vec3d* mutable_appliedvel();
  inline ::planner_vec3d* release_appliedvel();
  
  // optional .planner_obstacles obstacleSet = 7;
  inline bool has_obstacleset() const;
  inline void clear_obstacleset();
  static const int kObstacleSetFieldNumber = 7;
  inline const ::planner_obstacles& obstacleset() const;
  inline ::planner_obstacles* mutable_obstacleset();
  inline ::planner_obstacles* release_obstacleset();
  
  // @@protoc_insertion_point(class_scope:planner_plan)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_initstate();
  inline void clear_has_initstate();
  inline void set_has_goalstate();
  inline void clear_has_goalstate();
  inline void set_has_desiredvel();
  inline void clear_has_desiredvel();
  inline void set_has_appliedvel();
  inline void clear_has_appliedvel();
  inline void set_has_obstacleset();
  inline void clear_has_obstacleset();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::planner_vec3d > pathstate_;
  ::planner_vec3d* initstate_;
  ::planner_vec3d* goalstate_;
  ::planner_vec3d* desiredvel_;
  ::planner_vec3d* appliedvel_;
  ::planner_obstacles* obstacleset_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static planner_plan* default_instance_;
};
// -------------------------------------------------------------------

class ssl_planner_packet : public ::google::protobuf::Message {
 public:
  ssl_planner_packet();
  virtual ~ssl_planner_packet();
  
  ssl_planner_packet(const ssl_planner_packet& from);
  
  inline ssl_planner_packet& operator=(const ssl_planner_packet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ssl_planner_packet& default_instance();
  
  void Swap(ssl_planner_packet* other);
  
  // implements Message ----------------------------------------------
  
  ssl_planner_packet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ssl_planner_packet& from);
  void MergeFrom(const ssl_planner_packet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .planner_plan plans = 1;
  inline int plans_size() const;
  inline void clear_plans();
  static const int kPlansFieldNumber = 1;
  inline const ::planner_plan& plans(int index) const;
  inline ::planner_plan* mutable_plans(int index);
  inline ::planner_plan* add_plans();
  inline const ::google::protobuf::RepeatedPtrField< ::planner_plan >&
      plans() const;
  inline ::google::protobuf::RepeatedPtrField< ::planner_plan >*
      mutable_plans();
  
  // optional .planner_polygon plannerBound = 2;
  inline bool has_plannerbound() const;
  inline void clear_plannerbound();
  static const int kPlannerBoundFieldNumber = 2;
  inline const ::planner_polygon& plannerbound() const;
  inline ::planner_polygon* mutable_plannerbound();
  inline ::planner_polygon* release_plannerbound();
  
  // optional string comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // @@protoc_insertion_point(class_scope:ssl_planner_packet)
 private:
  inline void set_has_plannerbound();
  inline void clear_has_plannerbound();
  inline void set_has_comment();
  inline void clear_has_comment();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::planner_plan > plans_;
  ::planner_polygon* plannerbound_;
  ::std::string* comment_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ssl_5fplanner_2eproto();
  friend void protobuf_AssignDesc_ssl_5fplanner_2eproto();
  friend void protobuf_ShutdownFile_ssl_5fplanner_2eproto();
  
  void InitAsDefaultInstance();
  static ssl_planner_packet* default_instance_;
};
// ===================================================================


// ===================================================================

// planner_vec3d

// required float x = 1;
inline bool planner_vec3d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void planner_vec3d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void planner_vec3d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void planner_vec3d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float planner_vec3d::x() const {
  return x_;
}
inline void planner_vec3d::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool planner_vec3d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void planner_vec3d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void planner_vec3d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void planner_vec3d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float planner_vec3d::y() const {
  return y_;
}
inline void planner_vec3d::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float teta = 3;
inline bool planner_vec3d::has_teta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void planner_vec3d::set_has_teta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void planner_vec3d::clear_has_teta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void planner_vec3d::clear_teta() {
  teta_ = 0;
  clear_has_teta();
}
inline float planner_vec3d::teta() const {
  return teta_;
}
inline void planner_vec3d::set_teta(float value) {
  set_has_teta();
  teta_ = value;
}

// -------------------------------------------------------------------

// planner_point2d

// required float x = 1;
inline bool planner_point2d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void planner_point2d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void planner_point2d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void planner_point2d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float planner_point2d::x() const {
  return x_;
}
inline void planner_point2d::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool planner_point2d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void planner_point2d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void planner_point2d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void planner_point2d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float planner_point2d::y() const {
  return y_;
}
inline void planner_point2d::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// planner_circle

// required .planner_point2d center = 1;
inline bool planner_circle::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void planner_circle::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void planner_circle::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void planner_circle::clear_center() {
  if (center_ != NULL) center_->::planner_point2d::Clear();
  clear_has_center();
}
inline const ::planner_point2d& planner_circle::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::planner_point2d* planner_circle::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::planner_point2d;
  return center_;
}
inline ::planner_point2d* planner_circle::release_center() {
  clear_has_center();
  ::planner_point2d* temp = center_;
  center_ = NULL;
  return temp;
}

// required float radius = 2;
inline bool planner_circle::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void planner_circle::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void planner_circle::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void planner_circle::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float planner_circle::radius() const {
  return radius_;
}
inline void planner_circle::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional float orien = 3;
inline bool planner_circle::has_orien() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void planner_circle::set_has_orien() {
  _has_bits_[0] |= 0x00000004u;
}
inline void planner_circle::clear_has_orien() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void planner_circle::clear_orien() {
  orien_ = 0;
  clear_has_orien();
}
inline float planner_circle::orien() const {
  return orien_;
}
inline void planner_circle::set_orien(float value) {
  set_has_orien();
  orien_ = value;
}

// -------------------------------------------------------------------

// planner_polygon

// repeated .planner_point2d vertex = 1;
inline int planner_polygon::vertex_size() const {
  return vertex_.size();
}
inline void planner_polygon::clear_vertex() {
  vertex_.Clear();
}
inline const ::planner_point2d& planner_polygon::vertex(int index) const {
  return vertex_.Get(index);
}
inline ::planner_point2d* planner_polygon::mutable_vertex(int index) {
  return vertex_.Mutable(index);
}
inline ::planner_point2d* planner_polygon::add_vertex() {
  return vertex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::planner_point2d >&
planner_polygon::vertex() const {
  return vertex_;
}
inline ::google::protobuf::RepeatedPtrField< ::planner_point2d >*
planner_polygon::mutable_vertex() {
  return &vertex_;
}

// optional float orien = 2;
inline bool planner_polygon::has_orien() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void planner_polygon::set_has_orien() {
  _has_bits_[0] |= 0x00000002u;
}
inline void planner_polygon::clear_has_orien() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void planner_polygon::clear_orien() {
  orien_ = 0;
  clear_has_orien();
}
inline float planner_polygon::orien() const {
  return orien_;
}
inline void planner_polygon::set_orien(float value) {
  set_has_orien();
  orien_ = value;
}

// -------------------------------------------------------------------

// planner_obstacles

// repeated .planner_circle circles = 1;
inline int planner_obstacles::circles_size() const {
  return circles_.size();
}
inline void planner_obstacles::clear_circles() {
  circles_.Clear();
}
inline const ::planner_circle& planner_obstacles::circles(int index) const {
  return circles_.Get(index);
}
inline ::planner_circle* planner_obstacles::mutable_circles(int index) {
  return circles_.Mutable(index);
}
inline ::planner_circle* planner_obstacles::add_circles() {
  return circles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::planner_circle >&
planner_obstacles::circles() const {
  return circles_;
}
inline ::google::protobuf::RepeatedPtrField< ::planner_circle >*
planner_obstacles::mutable_circles() {
  return &circles_;
}

// repeated .planner_polygon polygons = 2;
inline int planner_obstacles::polygons_size() const {
  return polygons_.size();
}
inline void planner_obstacles::clear_polygons() {
  polygons_.Clear();
}
inline const ::planner_polygon& planner_obstacles::polygons(int index) const {
  return polygons_.Get(index);
}
inline ::planner_polygon* planner_obstacles::mutable_polygons(int index) {
  return polygons_.Mutable(index);
}
inline ::planner_polygon* planner_obstacles::add_polygons() {
  return polygons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::planner_polygon >&
planner_obstacles::polygons() const {
  return polygons_;
}
inline ::google::protobuf::RepeatedPtrField< ::planner_polygon >*
planner_obstacles::mutable_polygons() {
  return &polygons_;
}

// -------------------------------------------------------------------

// planner_plan

// required uint32 id = 1;
inline bool planner_plan::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void planner_plan::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void planner_plan::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void planner_plan::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 planner_plan::id() const {
  return id_;
}
inline void planner_plan::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// repeated .planner_vec3d pathState = 2;
inline int planner_plan::pathstate_size() const {
  return pathstate_.size();
}
inline void planner_plan::clear_pathstate() {
  pathstate_.Clear();
}
inline const ::planner_vec3d& planner_plan::pathstate(int index) const {
  return pathstate_.Get(index);
}
inline ::planner_vec3d* planner_plan::mutable_pathstate(int index) {
  return pathstate_.Mutable(index);
}
inline ::planner_vec3d* planner_plan::add_pathstate() {
  return pathstate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::planner_vec3d >&
planner_plan::pathstate() const {
  return pathstate_;
}
inline ::google::protobuf::RepeatedPtrField< ::planner_vec3d >*
planner_plan::mutable_pathstate() {
  return &pathstate_;
}

// required .planner_vec3d initState = 3;
inline bool planner_plan::has_initstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void planner_plan::set_has_initstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void planner_plan::clear_has_initstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void planner_plan::clear_initstate() {
  if (initstate_ != NULL) initstate_->::planner_vec3d::Clear();
  clear_has_initstate();
}
inline const ::planner_vec3d& planner_plan::initstate() const {
  return initstate_ != NULL ? *initstate_ : *default_instance_->initstate_;
}
inline ::planner_vec3d* planner_plan::mutable_initstate() {
  set_has_initstate();
  if (initstate_ == NULL) initstate_ = new ::planner_vec3d;
  return initstate_;
}
inline ::planner_vec3d* planner_plan::release_initstate() {
  clear_has_initstate();
  ::planner_vec3d* temp = initstate_;
  initstate_ = NULL;
  return temp;
}

// required .planner_vec3d goalState = 4;
inline bool planner_plan::has_goalstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void planner_plan::set_has_goalstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void planner_plan::clear_has_goalstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void planner_plan::clear_goalstate() {
  if (goalstate_ != NULL) goalstate_->::planner_vec3d::Clear();
  clear_has_goalstate();
}
inline const ::planner_vec3d& planner_plan::goalstate() const {
  return goalstate_ != NULL ? *goalstate_ : *default_instance_->goalstate_;
}
inline ::planner_vec3d* planner_plan::mutable_goalstate() {
  set_has_goalstate();
  if (goalstate_ == NULL) goalstate_ = new ::planner_vec3d;
  return goalstate_;
}
inline ::planner_vec3d* planner_plan::release_goalstate() {
  clear_has_goalstate();
  ::planner_vec3d* temp = goalstate_;
  goalstate_ = NULL;
  return temp;
}

// required .planner_vec3d desiredVel = 5;
inline bool planner_plan::has_desiredvel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void planner_plan::set_has_desiredvel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void planner_plan::clear_has_desiredvel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void planner_plan::clear_desiredvel() {
  if (desiredvel_ != NULL) desiredvel_->::planner_vec3d::Clear();
  clear_has_desiredvel();
}
inline const ::planner_vec3d& planner_plan::desiredvel() const {
  return desiredvel_ != NULL ? *desiredvel_ : *default_instance_->desiredvel_;
}
inline ::planner_vec3d* planner_plan::mutable_desiredvel() {
  set_has_desiredvel();
  if (desiredvel_ == NULL) desiredvel_ = new ::planner_vec3d;
  return desiredvel_;
}
inline ::planner_vec3d* planner_plan::release_desiredvel() {
  clear_has_desiredvel();
  ::planner_vec3d* temp = desiredvel_;
  desiredvel_ = NULL;
  return temp;
}

// required .planner_vec3d appliedVel = 6;
inline bool planner_plan::has_appliedvel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void planner_plan::set_has_appliedvel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void planner_plan::clear_has_appliedvel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void planner_plan::clear_appliedvel() {
  if (appliedvel_ != NULL) appliedvel_->::planner_vec3d::Clear();
  clear_has_appliedvel();
}
inline const ::planner_vec3d& planner_plan::appliedvel() const {
  return appliedvel_ != NULL ? *appliedvel_ : *default_instance_->appliedvel_;
}
inline ::planner_vec3d* planner_plan::mutable_appliedvel() {
  set_has_appliedvel();
  if (appliedvel_ == NULL) appliedvel_ = new ::planner_vec3d;
  return appliedvel_;
}
inline ::planner_vec3d* planner_plan::release_appliedvel() {
  clear_has_appliedvel();
  ::planner_vec3d* temp = appliedvel_;
  appliedvel_ = NULL;
  return temp;
}

// optional .planner_obstacles obstacleSet = 7;
inline bool planner_plan::has_obstacleset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void planner_plan::set_has_obstacleset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void planner_plan::clear_has_obstacleset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void planner_plan::clear_obstacleset() {
  if (obstacleset_ != NULL) obstacleset_->::planner_obstacles::Clear();
  clear_has_obstacleset();
}
inline const ::planner_obstacles& planner_plan::obstacleset() const {
  return obstacleset_ != NULL ? *obstacleset_ : *default_instance_->obstacleset_;
}
inline ::planner_obstacles* planner_plan::mutable_obstacleset() {
  set_has_obstacleset();
  if (obstacleset_ == NULL) obstacleset_ = new ::planner_obstacles;
  return obstacleset_;
}
inline ::planner_obstacles* planner_plan::release_obstacleset() {
  clear_has_obstacleset();
  ::planner_obstacles* temp = obstacleset_;
  obstacleset_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ssl_planner_packet

// repeated .planner_plan plans = 1;
inline int ssl_planner_packet::plans_size() const {
  return plans_.size();
}
inline void ssl_planner_packet::clear_plans() {
  plans_.Clear();
}
inline const ::planner_plan& ssl_planner_packet::plans(int index) const {
  return plans_.Get(index);
}
inline ::planner_plan* ssl_planner_packet::mutable_plans(int index) {
  return plans_.Mutable(index);
}
inline ::planner_plan* ssl_planner_packet::add_plans() {
  return plans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::planner_plan >&
ssl_planner_packet::plans() const {
  return plans_;
}
inline ::google::protobuf::RepeatedPtrField< ::planner_plan >*
ssl_planner_packet::mutable_plans() {
  return &plans_;
}

// optional .planner_polygon plannerBound = 2;
inline bool ssl_planner_packet::has_plannerbound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ssl_planner_packet::set_has_plannerbound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ssl_planner_packet::clear_has_plannerbound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ssl_planner_packet::clear_plannerbound() {
  if (plannerbound_ != NULL) plannerbound_->::planner_polygon::Clear();
  clear_has_plannerbound();
}
inline const ::planner_polygon& ssl_planner_packet::plannerbound() const {
  return plannerbound_ != NULL ? *plannerbound_ : *default_instance_->plannerbound_;
}
inline ::planner_polygon* ssl_planner_packet::mutable_plannerbound() {
  set_has_plannerbound();
  if (plannerbound_ == NULL) plannerbound_ = new ::planner_polygon;
  return plannerbound_;
}
inline ::planner_polygon* ssl_planner_packet::release_plannerbound() {
  clear_has_plannerbound();
  ::planner_polygon* temp = plannerbound_;
  plannerbound_ = NULL;
  return temp;
}

// optional string comment = 3;
inline bool ssl_planner_packet::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ssl_planner_packet::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ssl_planner_packet::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ssl_planner_packet::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ssl_planner_packet::comment() const {
  return *comment_;
}
inline void ssl_planner_packet::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ssl_planner_packet::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ssl_planner_packet::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ssl_planner_packet::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ssl_planner_packet::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ssl_5fplanner_2eproto__INCLUDED
